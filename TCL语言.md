## TCL语言

transaction control language——事务控制语言

事务：一个或一组sql语句自称的一个执行单元。每个sql语句是相互依赖的。这个执行单元要么全部执行，要么全部失败。

> 如果执行失败，则会全部回滚
>
> 如果执行成功，则事务被顺利执行

```mysql
# 案例：转账

# 张三丰  1000
# 郭襄    1000
update 表 set 张三丰的余额=500 where name='张三丰';
意外;
update 表 set 郭襄的余额=1500 where name='郭襄'; 
```

> 存储引擎——`SHOW ENGINES;`
>
> 在MySQL中的数据用各种不同的技术存储在文件或内存中。
>
> mysql中用的最多的存储引擎是innodb，myisam，memory。其中innodb支持事务

事务的acid属性：★

1. 原子性（atomicity）

   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

2. 一致性（consistency）

   事务必须使数据库从一个一致性状态转换到另一个一致性状态

   > 例如，转账前后，张三丰和郭襄的余额只和是一致的

3. 隔离型（isolation）

   各个事务之间互不干扰，即一个事务内部的操作及使用的数据对其他并发的事务是隔离的。

4. 持久性（durability）

   一旦一个事务被提交，它对数据库中数据的改变是永久性的。

分类：

1. 隐式的事务：事务没有明显的开始和结束的标记

   比如insert、update、delete语句

   ```mysql
   show variables like 'autocommit';
   ```

2. 显示事务：具有明显的开始和结束的标记

   前提：先关闭自动提交功能

   > ```mysql
   > # 只针对当前的事务有效
   > set autocimmit=0;
   > ```


### 1、事务的开启和关闭

步骤：

1. 开启事务

   ```mysql
   set autocommit=0;
   start transaction;  # 可选
   ```

2. 编写事务中的sal语句

   ```mysql
   select
   insert
   update
   delete
   
   # 不支持create，alter，drop
   ```

   > DDL语言没有事务之说

3. 结束事务

   ```mysql
   commit;  # 提交事务
   rollback;  # 回滚事务 
   
   
   提前设置保存点——`savepoint 保存点名称;`
   rollback to 保存点名称;  # 也能结束事务
   ```

### 2、delete和truncate在事务使用中的区别

   **`delete`支持回滚，`truncate`不支持回滚。**

### 3、事务的隔离

当同时运行多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致并发问题。

1. **脏读：读取到的是另一个事务已更改但尚未提交的临时数据**

   对于两个事务T1、T2，T1读取了已经被T2更新但没有提交的数据之后，若T2回滚，T1读取的内容就是临时且无效的数据

   侧重于临时数据

2. **不可重复读：读取的是另一个事务已提交之前尚未修改的过期数据**

   对于两个事务T1、T2，T1读取了一个字段，然后T2更新了该字段，T1再次读取同一个字段，值就不同了。

   侧重于过期数据

3. 幻读：**某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。**

   |      | T1                | T2             | 效果                                                         |
   | ---- | ----------------- | -------------- | ------------------------------------------------------------ |
   | 1    | `begin;`          |                |                                                              |
   | 2    |                   | 插入/删除 行x; |                                                              |
   | 3    |                   | 提交;          |                                                              |
   | 4.1  | 隐式的对 行x 读取 |                | 当前select的结果并不能支撑4.2步的操作                        |
   | 4.2  | （增、删、改）    |                | 插后插——错误<br />删后删——错误<br />插/删 后更改——影响的行数与实际看到的行数有区别——出现了幻觉 |
   
   T1从一个表中读取了一个字段时，然后T2在该表中插入了几行新行，如果T1再次读取同一个表，就会多出几行
   
   侧重于insert和delete

解决：设置隔离级别

> 一个事务与其他事务隔离的程度称为隔离级别，级别越高，数据一致性就越好，但并发性就越弱。



| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :--------------------------- | :----------------- | :------------------------------- | :------------------- |
| 未提交读（Read uncommitted） | ✔                  | ✔                                | ✔                    |
| 已提交读（Read committed）   | ✖                  | ✔                                | ✔                    |
| 可重复读（Repeatable read）  | ✖                  | ✖                                | ✔                    |
| 可串行化（Serializable ）    | ✖                  | ✖                                | ✖                    |

- 读未提交(Read Uncommitted)：允许脏读取，但不允许更新丢失。**写事务禁止其他事务再次写入，但允许其他事务读此行数据。**该隔离级别可以通过“排他写锁”实现。

  > 写事务允许读，但屏蔽写

  > 写事务允许读 -> 脏读
  >
  > 读事务允许写 -> 不可重复读

  可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。

- 读提交(Read Committed)：允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读事务允许其他事务继续访问该行数据，但是**未提交的写事务将会禁止其他事务访问该行**。

  > 写事务屏蔽读和写。

  > 写事务屏蔽读 -> 解决了脏读
  >
  > 读事务允许写 -> 不可重复读

  > Oracle默认

- 可重复读(Repeated Read)：禁止不可重复读和脏读，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

  > 读事务屏蔽写事务，写事务则禁止其他事务。
  >
  > > <font color=green>不能屏蔽insert、delete操作？</font>

  > 写事务屏蔽读 -> 解决了脏读
  >
  > 读事务屏蔽写（读事务期间，不能读取读事务过程中写事务提交后的结果） -> 解决了不可重复读
  >
  > > **在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据**

  > MySQL默认

  > 提问：为什么上了写锁（写操作），别的事务还可以读操作？
  >
  > 因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。

- 序列化(Serializable)：完全串行化的读，它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

  > 通过加锁实现

查看隔离级别：`select @@tx_isolation;`

设置隔离级别：`set session|global transaction isolation level read uncommitted;`



## 视图 

  视图——虚拟表，行和列的数据来自于定视图的查询中使用的表，使用方法和普通的表一样。

MySQL5.1的新特性

好处：

1. 重用MySQL语句

2. 简化复杂的sql操作

3. 保护数据，提高安全性

   将一些不敏感的数据封装成视图，与原始的基表分离。

应用场景：

- 多个地方用到相同的查询结果

|                  | 表       | 视图            |
| ---------------- | -------- | --------------- |
| 关键字           | view     | table           |
| 实际占用物理空间 | ✔        | 只保存了sql逻辑 |
| 使用             | 增删改查 | 一般只能查      |



### 创建视图：

```mysql
create view 视图名
as select语句（一般比较复杂）;
```

### 使用视图

同table的使用

查看视图的结构：

```mysql
desc 视图名;
show create view 视图名;  # 较为复杂
```

### 视图的修改：

> 对视图结构的修改

方式一：

```mysql
create or replace view 视图名
as select语句;
```

方式二：

```mysql
alter view 视图名 
as 查询语句;
```

### 删除视图

```mysql
drop view 视图1, 视图2, 视图3;
```

### 视图的更新——更新视图中的数据

**视图中数据的更新也会同步更新基表的数据**

视图能不能更新，与其创建时使用的select语句有关系，一下类型的视图是不能更新的

1. 包含以下关键字的sql语句：

   分组函数、distinct、group by、having、union或union all

2. select中包含子查询

3. 常量视图

4. join

   可以update但不能insert

5. from一个不可更新的视图

6. where字句的子查询引用了from字句中的表

## 变量

### 系统变量

1. 全局变量

   由系统提供，不是用户定义，属于服务器层面

   作用域：服务器层面，服务器每次启动，将为所有的全局变量赋初始值。**==但是不能跨重启（重启将初始化所有全局变量）==**

2. 会话session变量——**只针对一次连接**

   作用域：仅仅针对与当前的会话（连接）有效。

使用语法：

1. 查看所有的系统|会话变量

   ```mysql
   show global|[session] variables;
   ```

2. 查看满足条件的部分系统|会话变量

   ```mysql
   show global|[session] variables like '%char%';
   ```

3. 查看指定的某个系统|会话变量

   一般来讲，查看某个具体的值用`select`命令

   ```mysql
   select @@global|[session].系统变量名;
   ```

4. 为某个系统|会话变量赋值

   ```mysql
   # 方式1
   set global|[session] 系统变量名=值;
   # 方式2
   set @@global|[session].系统变量名=值;
   ```

### 自定义变量

1. 用户变量
2. 局部变量

使用步骤：

1. 声明
2. 赋值
3. 使用（查看、比较、计算等）

#### 用户变量

**作用域：针对当前的会话（连接）有效**

应用：应用在任何地方，`begin eng`里面或外面

使用：

**赋值操作符：= 或 :=**

> `set`支持两种
>
> `select`只支持`:=`
>
> 否则赋值=会和比较=混淆

1. 声明并初始化

   声明的同时必须初始化

   ```mysql
   set @用户变量名=值;
   set @用户变量名:= 值;
   select @用户变量名:=值;
   ```

2. 赋值

   1. 方式1：使用`set` 或 `select`重新设置
   2. 方式2：`select 字段名 into 变量名 from 表名;`

3. 使用——查看用户变量的值

   ```mysql
   select @用户变量名;
   ```

#### 局部变量

作用域：只在定义的`begin end`内部有效

应用在`begin end`中的第一句话

使用：

1. 声明

   ```mysql
   declare 变量名 类型;
   # 声明兵=并初始化
   declare 变量名 类型 default 值;
   ```

2. 赋值

   同用户变量

   1. set 或 select 变量名

      ```mysql
      set 局部变量名 =|:= 值;
      select @局部变量名 := 值;
      ```

   2. `select 字段 into 局部变量名 from 表名;`

3. 使用

   ```mysql
   select 局部变量名;
   ```

|                  | 用户变量                      | 局部变量                                    |
| ---------------- | ----------------------------- | ------------------------------------------- |
| 作用域           | 当前会话                      | `begin end`中                               |
| 定义和使用的位置 | 会话中的任何位置              | 只能在`begin end`中，且必须是第一句话       |
| 语法             | 需要加@符号<br />不用限定类型 | set不用加@，select必须加@<br />必须添加类型 |

## 存储过程和函数

### 存储过程

类似于Java中的方法

1. 提高代码的重用性
2. 简化代码的操作

存储过程：一组预先编译好的sql语句的集合，可以理解成批处理语句

好处：

1. 预先编译，减少编译次数，运行效率高
2. 减少和数据库服务器的通信次数

语法：

#### 创建

语法：

```mysql
create procedure 存储过程名(参数列表)
begin
	存储过程体：一组有效合法的sql语句;
end
```

参数列表：包含三部分

1. 参数模式
2. 参数名
3. 参数类型

举例：`in stuname varchar(20)`

注意：

1. 参数模式

   1. `IN`：该参数可以作为输入，也就是说需要调用方传入值

   2. `OUT`：作为输出，该参数可以作为返回值

      存储体里面不用写return语句

   3. `INOUT`：该参数既可以作为输入，也可以作为输出

      既需要传入值，也可以返回值

2. 如果存储过程体已有一个语句，`begin end`可以省略

3. 存储过程体中的每条sql语句要求必须加分号

4. 存储过程的结尾可以使用 delimiter 重新设置

   ```mysql
   delimiter 结束标记
   delimiter $
   ```

#### 调用

```mysql
call 存储过程名(实参列表);
```

1. `in`参数——传入变量或者常量都可以

2. `out`——传入用户变量

   ```mysql
   # 通过用户变量来接收返回值
   # 方法一：外部定义一个用户变量，让其接收out参数
   SET @boy_name=1/  # 可选，用户变量定义的同时必须赋初值
   CALL myp5('柳岩', @boy_name)/
   
   # 方法二：直接在调用时的实参列表中定义用户变量
   CALL myp5('柳岩', @boy_name)/
   #  最后select
   SELECT @boy_name/
   ```

3. `inout`——传入带有初值的用户变量

   **==在这种模式下，调用时该参数必须传入已经有值的变量，因为既要携带参数，又要接收返回值。==**

   ```mysql
   # 案例1：闯入a和b两个值，最终a和b都返回double
   CREATE PROCEDURE myp8(INOUT a INT, INOUT b INT)
   BEGIN 
   	SET a=a*2;
   	SET b=b*2;
   END /
   
   # 调用
   # 先定义两个用户变量
   SET @m=10;
   SELECT @n:=20;
   CALL myp8(@m, @n);
   SELECT @m, @n/
   ```

#### 删除、查看存储过程



```mysql
# 删除：同视图，但是一次只能删除一个
drop procedure 存储过程名;

# 查看
show create procedure 存过·存储过程名;
```



```mysql
# 测试
# 案例：创建存储过程或函数实现传入一个日期，格式化成xx年xx月xx日并返回

CREATE PROCEDURE myp7(IN 日期 DATE, OUT xx VARCHAR(20))
BEGIN 
	SELECT DATE_FORMAT(日期, '%Y年%m月%d日') INTO xx;
END /

CALL myp7('1995-12-26', @日期)/
SELECT @日期/
```

### 函数



## 流程控制结构